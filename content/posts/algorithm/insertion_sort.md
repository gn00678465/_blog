---
title: "[演算法] Insertion Sort / 插入排序"
date: 2021-02-01T14:34:22+08:00
categories: "演算法"
tags: [排序]
enableMermaid: false
enableMathJax: true
draft: false
---

## Bubble Sort / 泡沫排序
插入排序與泡沫排序同為排序演算法中比較基礎的方式，所需的時間會隨著數列的長度**平方成長**。

排序方式為從一個數列中，由第二個元素開始往前逐一比較，再將元素插入適當的位置。

可以參考動態的[視覺網站](https://visualgo.net/en/sorting)，可以比較清楚的知道排序的方式。

## 排序流程
假設目前有一數列 `[8, 5, 10, 6]`
1. 第一輪排序。
    1. 取 5 開始往前比較， 8 > 5 ，交換。`[5, 8, 10, 6]`
2. 第二輪排序
    1. 取 10 開始往前比較，8 < 10 不交換。
    1. 再往前比較， 5 < 10 不交換。`[5, 8, 10, 6]`
3. 第三輪排序
    1. 取 6 開始往前比較， 10 > 6 交換。`[5, 8, 6, 10]`
    1. 再往前比較， 8 > 6 交換。`[5, 6, 8, 10]`
    1. 再往前比較， 5 < 6 不交換。
1. 排序完成
- 以上流程，排序次數為**數列長度 - 1**。

## 時間複雜度
- 要執行 n - 1 輪，每輪要比較 1 ... n-1 次。
1. 當數列元素有 4 個時，需要比對 $1 + 2 + 3 = 6$ 次。
2. 當數列元素有 5 個時，需要比對 $1 + 2 + 3 + 4 = 10$ 次。
3. 當數列元素有 n 個時，需要比對
    - $1 + ... (n - 1) = (n * (n - 1))/2 = n^2/2 - n/2$ (等差級數)
    - 當 n 有無限 $\infty$ 多個元素時，平方以外的值可以忽略不計。
4. Insertion Sort 的時間複雜度為 **$O(n^2)$**，平方成長。

## JavaScript 插入排序
```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = i -1; j >= 0; j--) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      }
    }
  }
}
```

## 當原始陣列已為已排序時

當傳入資料已經為排序完成的數列時，在整輪的排序中都沒有交換，可直接判斷排序完成。

```js
function insertionSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    for (let j = i -1; j >= 0; j--) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
      } else {
        // 當判斷順序不須交換時結束此圈。
        break;
      }
    }
  }
}
```